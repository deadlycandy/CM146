import mathfrom heapq import heappop, heappushdef find_path(source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    # source = findBox(source_point[1], source_point[0], mesh)    # # path.append(((source[0], source[2]), (source[1], source[3])))    # destination = findBox(destination_point[1], destination_point[0], mesh)    frontier = []    heappush(frontier, (0, source_point))    came_from = {}    cost_so_far = {}    came_from[source_point] = None    cost_so_far[source_point] = 0    #    while len(frontier) > 0:        current = heappop(frontier)        if current == destination_point:            path.append(destination_point)            _visit = came_from[destination_point]            # Loops till intial position            while _visit != source_point:                path.append(_visit)                _visit = came_from[_visit]            path.append(source_point)            path.reverse()            return path, boxes.keys()        # print("\n Current: ", current)        # neighbors = findBox(current[1][1], current[1][0], mesh)        for neighbors in findBox(current[1][1], current[1][0], mesh):            # print("\n Cost: ", type(cost_so_far[current[1]]))            # print("\n Current: ", type(current[1][0]))            print("\n neighbors: ", neighbors)            # print("\nI: ", i)            # print("\n next: ", neighbors[i])            # # print("\n next: ", neighbors)            new_cost = cost_so_far[current[1]] + euclideanDistance(current[1][1], current[1][0], neighbors[1], neighbors[0])            # if next not in cost_so_far or new_cost < cost_so_far[next]:            #     cost_so_far[next] = new_cost            #     priority = new_cost + euclideanDistance(destination_point[1], destination_point[0], next[1], next[0])            #     heappush(frontier, (priority, next))            #     came_from[next] = current            # # print("\ncomplete: ", i)            # i = i + 1    return path, boxes.keys()def euclideanDistance(x1, y1, x2, y2):    distance = math.sqrt((math.pow(x2 - x1, 2)) + (math.pow(y2 - y1, 2)))    return distancedef findBox(x, y, mesh):    for i in range(0, len(mesh['boxes'])):        # print("X: ", type(x))        # print("\Mesh: ", type(x))        if (mesh['boxes'][i][2] < x < mesh['boxes'][i][3] and mesh['boxes'][i][0] < y < mesh['boxes'][i][1]):            # print(((mesh['boxes'][i][0],mesh['boxes'][i][2]), (mesh['boxes'][i][1],mesh['boxes'][i][3]),            #         (mesh['boxes'][i][0],mesh['boxes'][i][3]), (mesh['boxes'][i][1], mesh['boxes'][i][2])))            return (((mesh['boxes'][i][0],mesh['boxes'][i][2]), (mesh['boxes'][i][1],mesh['boxes'][i][3]),                    (mesh['boxes'][i][0],mesh['boxes'][i][3]), (mesh['boxes'][i][1], mesh['boxes'][i][2])))