from math import inf, sqrtfrom heapq import heappop, heappushdef find_path(source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    stod = []    boxes = {}    for i in range (0,len(mesh['boxes'])):        if  (mesh['boxes'][i][2] <= source_point[1] <= mesh['boxes'][i][3] and mesh['boxes'][i][0] < source_point[0] < mesh['boxes'][i][1]):            #print("source: " + str(mesh['boxes'][i]))            #source = mesh['boxes'][i]            print(str(mesh['boxes'][i][0])+" "+str(mesh['boxes'][i][2])+" "+str(mesh['boxes'][i][1])+" "+str(mesh['boxes'][i][3]))            stod.append(((mesh['boxes'][i][0],mesh['boxes'][i][2]) ,(mesh['boxes'][i][1],mesh['boxes'][i][3])))        if  (mesh['boxes'][i][2] <= destination_point[1] <= mesh['boxes'][i][3] and mesh['boxes'][i][0] < destination_point[0] < mesh['boxes'][i][1]):            #print("destination: " + str(mesh['boxes'][i]))            stod.append(((mesh['boxes'][i][0],mesh['boxes'][i][2]) ,(mesh['boxes'][i][1],mesh['boxes'][i][3])))            # y1 x1 y2 x2    #path.append(stod[1]) # append source    srcconcat =  (stod[1][0][0],stod[1][1][0],stod[1][0][1],stod[1][1][1])    destconcat = (stod[0][0][0],stod[0][1][0],stod[0][0][1],stod[0][1][1])    estdist = euclideanDistance(source_point[1], source_point[0], destination_point[1], destination_point[0])    print("estdist: " + str(estdist))        #cost_so_far = 0    #print("stod[0]: " + str(stod[0]))    #print("cost_so_far[srcconcat]: " + str(cost_so_far[srcconcat]))    """    print("current: " + str(current))    print("currentconcat: " + str(currentconcat))    print("srcconcat: " + str(srcconcat))    print("destconcat: " + str(destconcat))    """    boxes[srcconcat] = None    frontier = [srcconcat]    cost_so_far = {}    cost_so_far[srcconcat] = 0    new_cost = inf    came_from = {}    came_from[srcconcat] = None        while frontier:        current = heappop(frontier)        currentconcat = (current[0], current[1], current[2], current[3])        if currentconcat == destconcat:            addto = destconcat            print("IM IN ")            while srcconcat not in path:                path = [addto] + path                addto = came_from[addto]            break        for a in mesh['adj'][currentconcat]:            print("a: " + str(a))            amid = boxmidpt(a)            #print("boxmidpt(a) " + str(amid))            #new_cost = cost_so_far[currentconcat] + euclideanDistance(currentconcat[1], currentconcat[0], amid[0], amid[1])            #if a not in came_from or new_cost < cost_so_far[a]:                #cost_so_far[a] = new_cost            if a not in came_from:                 #print("cost_so_far[a]: " + str(cost_so_far[a]))                heappush(frontier, a)                came_from[a] = currentconcat # current?    boxes = came_from    #print("came_from: " + str(came_from))    print("path: " + str(path))    if destconcat not in came_from:        print("Can't find path")        print("destconcat: " + str(destconcat))        return path, boxes.keys()        """        if a == destconcat and aconcat not in path:            print("destination is in adjacent box")            path.append(aconcat) #((a[0],a[2]),(a[1],a[3]))            print(" ")        """                        #new_cost = cost_so_far[current[1]] + euclideanDistance(current[1][1], current[1][0], neighbors[i][1], neighbors[i][0])        #if neighbors[i] not in cost_so_far or new_cost < cost_so_far[neighbors[i]]:            #cost_so_far[neighbors[i]] = new_cost            #print("cost_so_far: " + str(cost_so_far))            #priority = new_cost + euclideanDistance(destination_point[1], destination_point[0], neighbors[i][1], neighbors[i][0])            #heappush(frontier, (priority, neighbors[i]))            #came_from[neighbors[i]] = current                        #box = findBox(neighbors[i][0], neighbors[i][1],mesh)            #path.append(((destination_point[0],destination_point[1]) ,(mesh['boxes'][i][1],mesh['boxes'][i][3])))            #path.append(((neighbors[i][0],box[i][0]) ,(neighbors[i][1],box[i][1])))            #print("box :" + str(box))            #print("neighbors["+str(i)+"]: "+str(neighbors[i]))            #print("neighbors["+str(i)+"][0]: "+str(neighbors[i][0]))        # # print("\ncomplete: ", i)        # i = i + 1            coordPath = []    #print("path[coord]    for coord in path:        coordPath.append(((coord[0],coord[2]),(coord[1],coord[3])))    path = coordPath    """    print("path: " + str(path))    for coord in range(0,len(path)):        print("srcconcat: " + str(srcconcat))        print("coord: " + str(path[coord]))        print(" coords: " + str((path[coord][0],path[coord][2],path[coord][1],path[coord][3])))        if path[coord] == srcconcat and path[coord+1] == destconcat:            coordPath.append((source_point, destination_point))            break        elif path[coord] == srcconcat:            print("wow")            coordPath.append((source_point, boxmidpt(path[coord+1])))        elif path[coord+1] == destconcat:            coordPath.append((boxmidpt(path[coord]), destination_point))            break         else:            coordPath.append((boxmidpt(path[coord]), boxmidpt(path[coord+1])))        print("midpt of " + str(path[coord]) +" is " + str(boxmidpt(path[coord])))        """    print("path: "+str(path))    return path, boxes.keys()def euclideanDistance(x1, y1, x2, y2):    distance = sqrt((pow(x2 - x1, 2)) + (pow(y2 - y1, 2)))    return distance    def boxmidpt(abox): # y1 y2 x1 x2 i think    x = abox[0] + ((abox[2] - abox[0])/2)    y = abox[1] + ((abox[3] - abox[1])/2)    return (y,x)def findBox(x, y, mesh):    for i in range(0, len(mesh['boxes'])):        # print("X: ", type(x))        # print("\Mesh: ", type(x))        if (mesh['boxes'][i][2] < x < mesh['boxes'][i][3] and mesh['boxes'][i][0] < y < mesh['boxes'][i][1]):            # print(((mesh['boxes'][i][0],mesh['boxes'][i][2]), (mesh['boxes'][i][1],mesh['boxes'][i][3]),            #         (mesh['boxes'][i][0],mesh['boxes'][i][3]), (mesh['boxes'][i][1], mesh['boxes'][i][2])))            return (((mesh['boxes'][i][0],mesh['boxes'][i][2]), (mesh['boxes'][i][1],mesh['boxes'][i][3]),                    (mesh['boxes'][i][0],mesh['boxes'][i][3]), (mesh['boxes'][i][1], mesh['boxes'][i][2])))